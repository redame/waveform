<!--
CUSTOM ELEMENT: dagre-d3
BY: DM, but all the hard work is from [github.com/cpettitt/dagre-d3]


USEAGE:
    <dagre-d3 id="my_graph"></dagre-d3>
    <script>
        document.getElementById('my_graph').Render(nodeList);
	</script>
    
nodeList must be an array of objects that have the following properties:
    .id - the index of the node in the nodeList array
    .name - string giving the display name of the node
    .directAfter - array of node objects which are to be shown as descending from the current node
	.repeat - -1, means it doesn't repeat, any other value will put it into repeat-rendering mode, and the value is shown to the right
	
	The rendering is super messy...but it shows what we need for now.

-->
<link rel="import" href="polymer/polymer.html">

<polymer-element name="dagre-d3" attributes=''> 
<template>
    <style>
    text {
      font-weight: 300;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
      font-size: 14px;
    }
    
    .node rect {
      stroke: #999;
    }
    
    .edgePath path {
      stroke: #333;
      stroke-width: 1.5px;
      fill: none;
    }
	#info{
		margin: 5px;
		min-height: 100px;
		background: #ccc;
		border: 1px solid #000;
	}
	#svg_wrapper{
		max-width: 1200px;
		overflow-x: scroll;
		cursor: default;
	}
	::-webkit-scrollbar {
	width: 10px;
	height: 10px;
	}
	::-webkit-scrollbar-button {
	width: 0;
	height: 0;
	display: none;
	}
	::-webkit-scrollbar-thumb {
	background-color: rgba(0,0,0,0.2);
	-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
	}
	</style>
	<div id='svg_wrapper' nodrag>
    <svg width=650 height=680 id="thesvg"></svg>
	</div>
	<div id='info'></div>
</template>
<script src="d3.js"></script>
<script src="dagre-d3.js">move cursor over map for info</script>

<script>
	Polymer('dagre-d3',{
        Render: function(nodeList){
            // Create the input graph
            var g = new dagreD3.Digraph();
            
			var extraCss = {labelStyle: 'fill: #00f;'}
			
            for(var i=0; i<nodeList.length;i++){
				var x= nodeList[i].repeat!=-1 ?  JSON.parse(JSON.stringify(extraCss))  : {}; //clone;
				x.label = nodeList[i].name;
                g.addNode(i,x);
            }
			var edgeStyles = [];
			var edgeRepeats = [];
			extraCss = {style:'stroke: #00f;'}; //it seems some things have to be done here and some in path renderer...maybe there's a way of avoiding this mess...?...ahh it's the child hmm
            for(var i=0; i<nodeList.length;i++)
                for(var j=0; j<nodeList[i].directBefore.length;j++){
					edgeStyles.push(nodeList[i].directBefore[j].directAfter.length > 4 ? 'opacity: 0.3;' : '');//if there are loads of things after the jth item then weaken the arrow opacity.
					edgeRepeats.push(nodeList[i].directBefore[j].repeat != -1 ? 1: 0);
                    g.addEdge(null,nodeList[i].directBefore[j].id,i,nodeList[i].directBefore[j].repeat != -1   ? JSON.parse(JSON.stringify(extraCss))  : {});
				}
            
            // Create the renderer
            var renderer = new dagreD3.Renderer();
			var svg = this.$.thesvg;
            
            // Override drawNodes to add repeats
            var oldDrawNodes = renderer.drawNodes();
            renderer.drawNodes(function(graph, root) {
              var svgNodes = oldDrawNodes(graph, root);
				svgNodes.each(function(u) { 
					if(nodeList[u].repeat != -1){
						var newRect = this.firstChild.cloneNode();
						newRect.setAttribute('x',parseInt(newRect.getAttribute('x'))+5);
						newRect.setAttribute('y',parseInt(newRect.getAttribute('y'))+5);
						this.insertBefore(newRect,this.firstChild);
						var w = parseInt(newRect.getAttribute('width'));
						var x = parseInt(newRect.getAttribute('x'));
						var t = document.createElementNS(svg.namespaceURI,'text');
						t.setAttribute('text-anchor','left');
						t.setAttribute('style','fill: #00f');
						var ts = document.createElementNS(svg.namespaceURI,'tspan');
						ts.setAttribute('x',w+x+4);
						ts.innerHTML = "x" + nodeList[u].repeat;
						t.appendChild(ts);
						this.appendChild(t);
					}
				});
              return svgNodes;
            });
            
			//override drawedgepaths to weaken the opacity of the most prolific edge-spawning nodes
			var oldDrawEdgePaths = renderer.drawEdgePaths();
			renderer.drawEdgePaths(function (graph, root) {
				var svgEdges = oldDrawEdgePaths(graph, root);
				svgEdges.each(function(s,u){
					this.setAttribute('style',edgeStyles[u]);
						
				});
				return svgEdges;
			});


            
            // Disable pan and zoom
            renderer.zoom(false);
            
            
            
            // Run the renderer. This is what draws the final graph.

            var layout = renderer.run(g, d3.select(svg));

            // Center the graph
            var b = svg.getBBox();
            svg.setAttribute('width', b.width);
            svg.setAttribute('height', b.height);
			var elInfo = this.$.info;
			d3.select(svg).selectAll("rect").on("mouseover", function(){
				var id = d3.select(this).data()[0];
				if(id)
					elInfo.innerHTML = "<b>" + nodeList[id].name + "</b><br>" +
										"directly before: " + nodeList[id].directBefore.map(function(x){return x.name}).join(", ") + "<br>" +
										"directly after: " + nodeList[id].directAfter.map(function(x){return x.name}).join(", ") + "<br>" +
										(nodeList[id].infoHTML ? nodeList[id].infoHTML : "");
				else
					elInfo.innerHTML = "move cursor over map for info";
			});		  
            
			// duplicate the path data for repeated edges...adding 5 to x and y ...this is super hacky.
			d3.select(svg).selectAll(".edgePath").each(function(s,u){
				if(edgeRepeats[u]){
					var d = this.firstChild.getAttribute('d');
					d = d + "," + d.match(/[a-zA-Z]?[0-9\.]+/g).map(function(x){return x.match(/[A-Za-z]*/)[0] + (parseFloat(x.match(/[0-9\.]+/)[0])+5)}).join(",");
					this.firstChild.setAttribute('d',d);
				}
			});
			
        }
    });
</script>
</polymer-element>